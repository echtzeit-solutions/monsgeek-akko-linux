Bug Report: GET_MACRO (0x8B) Read Stride Mismatch
==================================================

Summary
-------

The GET_MACRO command (0x8B) uses a macro index stride of 512 bytes (0x200),
but SET_MACRO (0x0B) saves with a stride of 256 bytes (0x100). Macro playback
also uses 256 bytes. This means reading back any macro with index >= 1 returns
wrong data.

Reproduction
------------

1. Save macros to indices 0, 1, and 2 using SET_MACRO (0x0B)
2. Read them back using GET_MACRO (0x8B)
3. Expected: GET index 0 -> macro 0, GET index 1 -> macro 1, GET index 2 -> macro 2
4. Actual: GET index 0 -> macro 0 (correct), GET index 1 -> macro 2 (wrong), GET index 2 -> empty

Root Cause
----------

In the GET_MACRO (0x8B) handler within the vendor command dispatch function,
the flash read address is calculated as:

    address = FLASH_MACROS_BASE + macroIndex * 512 + chunkIndex * 64

The multiplication by 512 (left shift by 9) should be multiplication by 256
(left shift by 8), to match:

- SET_MACRO save: macro_id * 256 (per-slot within 2KB erase pages)
- Macro playback: macro_id * 256
- GET_MACRO read: macroIndex * 512 -- incorrect, should be 256

Impact
------

- Macros at odd indices (1, 3, 5, ...) can never be read back via GET_MACRO
- GET_MACRO for index N actually returns data saved at index N*2
- Macro playback is not affected (uses the correct 256-byte stride)
- The official web app never calls GET_MACRO (it caches macros in browser
  localStorage), so this bug is hidden

Fix
---

In the GET_MACRO (0x8B) handler, change the macro index shift from 9 to 8:

    // Before (incorrect):
    macroIndex << 9    // = macroIndex * 512

    // After (correct):
    macroIndex << 8    // = macroIndex * 256

Affected
--------

Firmware version 4.07 (device ID 2949). Other versions not tested but likely
share the same code.


==================================================


缺陷报告：GET_MACRO (0x8B) 读取步长不匹配
==================================================

概述
----

GET_MACRO 命令 (0x8B) 使用宏索引步长 512 字节 (0x200)，但 SET_MACRO (0x0B)
保存时使用步长 256 字节 (0x100)。宏回放也使用 256 字节步长。因此，读取索引
>= 1 的宏时会返回错误数据。

复现步骤
--------

1. 使用 SET_MACRO (0x0B) 分别保存宏到索引 0、1、2
2. 使用 GET_MACRO (0x8B) 读取
3. 预期结果：GET 索引 0 → 宏 0，GET 索引 1 → 宏 1，GET 索引 2 → 宏 2
4. 实际结果：GET 索引 0 → 宏 0（正确），GET 索引 1 → 宏 2（错误），GET 索引 2 → 空

根本原因
--------

在厂商命令分发函数中处理 GET_MACRO (0x8B) 时，Flash 读取地址的计算方式为：

    address = FLASH_MACROS_BASE + macroIndex * 512 + chunkIndex * 64

其中乘以 512（左移 9 位）应改为乘以 256（左移 8 位），以与以下逻辑保持一致：

- SET_MACRO 保存：macro_id * 256（在 2KB 擦除页内按槽偏移）
- 宏回放：macro_id * 256
- GET_MACRO 读取：macroIndex * 512 -- 错误，应为 256

影响范围
--------

- 奇数索引的宏（1、3、5、……）通过 GET_MACRO 永远无法正确读取
- GET_MACRO 读取索引 N 实际返回的是保存在索引 N*2 处的数据
- 宏回放不受影响（使用正确的 256 字节步长）
- 官方 Web 应用从未调用 GET_MACRO（宏缓存在浏览器 localStorage 中），因此此
  缺陷被隐藏

修复方案
--------

在 GET_MACRO (0x8B) 处理代码中，将宏索引的移位从 9 改为 8：

    // 修改前（错误）：
    macroIndex << 9    // = macroIndex * 512

    // 修改后（正确）：
    macroIndex << 8    // = macroIndex * 256

影响版本
--------

固件版本 4.07（设备 ID 2949）。其他版本未测试，但可能存在相同问题。
